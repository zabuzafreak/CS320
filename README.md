# How can I ensure that my code, program, or software is functional and secure?
To ensure it's functional, we examine the requirements of the software, and then use various testing methods so that we are certain it meets those requirements. When it comes to security, there are many tools available for differing languages and IDEs so that we can check for potential security risks in our imported packages and frameworks.
# How do I interpret user needs and incorporate them into a program?
Determining user needs can always be a bit of a challenge. In this course, many of the requirements were laid out for us. In my own personal projects, I begin with a broad-scope definition of what my software aims to accomplish. From there, I perform several "zoom-in" analysis layers. In practice, it looks something like this: "I want to create a build calculator for this game I play. The application should allow users to mix and match various equipment and skills and perform calculations based on that." Now I would zoom-in and say, "in order to properly store item data, we'll need a data format and some pipeline to load that data from an external site that can be updated if the data in game changes". Then, another zoom-in, "we need to plan out each potential attribute that this data could have, so that we can properly store this in memory while using the application". This process repeats until I am certain that I have everything covered, at which point I move into development (though there is some light development work happening during the planning.
# How do I approach designing software?
Most of my approach is covered during my example of interpreting user needs. I always start with the simplest top-level summary of what my software should accomplish. From there, I focus more and more, down level after level until eventually we're at the lowest level (well... maybe not assembly or binary, but as close as we can reasonably get). I find this approach to be very effective because it ensures we never lose the plot. If you start with the tiny individual pieces, it can be easy to create extra moving parts that don't need to be there or end up with software that doesn't actually accomplish what it should (or at least not to a satisfactory level).
